import Lean
import Mathlib.Tactic.ToAdditive

open Lean System

-- TODO: Move.
namespace ToAdditive

/- NOTE: I'm guessing this is the inverse of guessNameDict? -/
private def reverseGuessNameDict (is_comm : Bool) : List String → List String
| "nonneg" :: s        => addCommPrefix is_comm "one" :: "le"    :: reverseGuessNameDict false s
| "pos" :: s           => addCommPrefix is_comm "one" :: "lt"       :: reverseGuessNameDict false s
| "nonpos" :: s        => addCommPrefix is_comm "le" :: "one"    :: reverseGuessNameDict false s
--| "neg" :: s           => addCommPrefix is_comm "lt" :: "one"       :: reverseGuessNameDict false s
| "single" :: s        => "mul" :: addCommPrefix is_comm "single"    :: reverseGuessNameDict false s
| "support" :: s       => "mul" :: addCommPrefix is_comm "support"   :: reverseGuessNameDict false s
| "tsupport" :: s      => "mul" :: addCommPrefix is_comm "tsupport"  :: reverseGuessNameDict false s
| "indicator" :: s     => "mul" :: addCommPrefix is_comm "indicator" :: reverseGuessNameDict false s
| "vadd" :: s          => addCommPrefix is_comm "smul"      :: reverseGuessNameDict false s
| "neg" :: s           => addCommPrefix is_comm "inv"       :: reverseGuessNameDict false s
| "sub" :: s           => addCommPrefix is_comm "div"       :: reverseGuessNameDict false s
| "zero" :: s          => addCommPrefix is_comm "one"      :: reverseGuessNameDict false s
| "sum" :: s           => addCommPrefix is_comm "prod"       :: reverseGuessNameDict false s
| "finsum" :: s        => addCommPrefix is_comm "finprod"    :: reverseGuessNameDict false s
| "nsmul" :: s         => addCommPrefix is_comm "pow"     :: reverseGuessNameDict false s
--| "nsmul" :: s         => addCommPrefix is_comm "npow"     :: reverseGuessNameDict false s
| "zsmul" :: s         => addCommPrefix is_comm "zpow"     :: reverseGuessNameDict false s
| "add" :: "monoid" :: s      => (addCommPrefix is_comm "monoid")    :: reverseGuessNameDict false s
| "add" :: "submonoid" :: s   => (addCommPrefix is_comm "submonoid") :: reverseGuessNameDict false s
| "add" :: "group" :: s       => (addCommPrefix is_comm "group")     :: reverseGuessNameDict false s
| "add" :: "subgroup" :: s    => (addCommPrefix is_comm "subgroup")  :: reverseGuessNameDict false s
| "add" :: "semigroup" :: s   => (addCommPrefix is_comm "semigroup") :: reverseGuessNameDict false s
| "add" :: "magma" :: s       => (addCommPrefix is_comm "magma")     :: reverseGuessNameDict false s
| "add" :: "haar" :: s        => (addCommPrefix is_comm "haar")      :: reverseGuessNameDict false s
| "add" :: "prehaar" :: s     => (addCommPrefix is_comm "prehaar")   :: reverseGuessNameDict false s
| "add" :: "unit" :: s        => (addCommPrefix is_comm "unit")      :: reverseGuessNameDict false s
| "add" :: "units" :: s       => (addCommPrefix is_comm "units")     :: reverseGuessNameDict false s
| "add" :: s                  => addCommPrefix is_comm "mul"       :: reverseGuessNameDict false s
| "comm" :: s        => reverseGuessNameDict true s
| x :: s             => (addCommPrefix is_comm x :: reverseGuessNameDict false s)
| []                 => bif is_comm then ["comm"] else []

/-- Reverse name autogenerated by `to_additive`. -/
def reverseGuessName : String → String :=
  String.mapTokens ''' $
  fun s => String.intercalate (String.singleton '_') $
  reverseGuessNameDict false (s.splitOn "_")

end ToAdditive

-- TODO: Move
namespace String 

/- Check if a string is contained in another one. -/
partial def isSubstrOf (target str : String) : Bool :=
  loop "" 0
where
  loop (acc : String) (pos : String.Pos) : Bool :=
    if pos.byteIdx + target.endPos.byteIdx > str.endPos.byteIdx then
      false
    else if str.substrEq pos target 0 target.endPos.byteIdx then
      true
    else
      loop acc (str.next pos)

end String 

/- Find file path from module imported from Mathbin. -/
def pathFromMathbinImport (mod : Name) : MetaM (Option FilePath) := do 
  let mathbinPath : System.FilePath := "." / "lean_packages" / "mathlib3port"
  SearchPath.findWithExt [mathbinPath] "lean" mod

/- Given a theorem name and a file path, extract the proof text. -/
def proofSource (thm : Name) (modulePath : FilePath) : MetaM (Option String) := do
  let mut res := "" 
  for thmName in #[thm.toString, ToAdditive.reverseGuessName thm.toString] do 
    let keywords := 
      "(theorem|instance|class|attribute|section|namespace|def|variable)"
    let matchThmBody := 
      "'/theorem " ++ thmName ++ "/{flag=1;next}/" ++ keywords ++ "/{flag=0}flag'"
    let args := #[matchThmBody, modulePath.toString]
    dbg_trace s!"Running awk witha rgs: {args}. \n"
    let output ← IO.Process.output { cmd := "awk", args := args }
    if output.exitCode != 0 then 
      res := output.stdout
    if !res.isEmpty then 
      break 
  
  return (if res.isEmpty then none else some res)

/- Given a list of premises and proof text, get rid of the ones that do not 
appear. We take into account `ToAdditive` name translations. -/
def filterUserPremises (premises : List Name) (proofSource : String) : List Name := 
  let appearsInProof (s : String) : Bool := s.isSubstrOf proofSource
  premises.filter (fun p => 
    [p.toString, ToAdditive.reverseGuessName p.toString].any appearsInProof)
