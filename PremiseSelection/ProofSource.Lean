import Lean
import Mathlib.Tactic.ToAdditive

open Lean System

-- let theoremDef := "theorem " ++ toString theoremPremises.name
--       backIter := backIter.forward theoremDef.length
--       -- Find beginning of theorem definition.
--       while (frontIter.extract backIter) != theoremDef ∧ backIter.hasNext do 
--         frontIter := frontIter.next
--         backIter := backIter.next
--       -- Keep going until next theorem or end of file.
--       while (frontIter.extract backIter) != "theorem" ∧ backIter.hasNext do 
--         backIter := backIter.next
--       -- Extract block with the rpoof of the theorem.
--       let block := frontIter.extract backIter
--       dbg_trace s!"{theoremDef} +++ {block}"
--       -- NOTE: THIS DOES NOT WORK, e.g. @[to_additive] stuff....
--       -- Reset iterators for next search.
--       backIter := backIter.prevn 7 
--       frontIter := backIter 

--       break

#check ToAdditive.guessName

/- -/
def pathFromImport (mod : Name) : MetaM (Option FilePath) := do 
  let mathbinPath : System.FilePath := "." / "lean_packages" / "mathlib3port"
  SearchPath.findWithExt [mathbinPath] "lean" mod

namespace ToAdditive

/- NOTE: I'm guessing this is the inverse of guessNameDict? -/
private def reverseGuessNameDict (is_comm : Bool) : List String → List String
| "nonneg" :: s        => addCommPrefix is_comm "one" :: "le"    :: reverseGuessNameDict false s
| "pos" :: s           => addCommPrefix is_comm "one" :: "lt"       :: reverseGuessNameDict false s
| "nonpos" :: s        => addCommPrefix is_comm "le" :: "one"    :: reverseGuessNameDict false s
--| "neg" :: s           => addCommPrefix is_comm "lt" :: "one"       :: reverseGuessNameDict false s
| "single" :: s        => "mul" :: addCommPrefix is_comm "single"    :: reverseGuessNameDict false s
| "support" :: s       => "mul" :: addCommPrefix is_comm "support"   :: reverseGuessNameDict false s
| "tsupport" :: s      => "mul" :: addCommPrefix is_comm "tsupport"  :: reverseGuessNameDict false s
| "indicator" :: s     => "mul" :: addCommPrefix is_comm "indicator" :: reverseGuessNameDict false s
| "vadd" :: s          => addCommPrefix is_comm "smul"      :: reverseGuessNameDict false s
| "neg" :: s           => addCommPrefix is_comm "inv"       :: reverseGuessNameDict false s
| "sub" :: s           => addCommPrefix is_comm "div"       :: reverseGuessNameDict false s
| "zero" :: s          => addCommPrefix is_comm "one"      :: reverseGuessNameDict false s
| "sum" :: s           => addCommPrefix is_comm "prod"       :: reverseGuessNameDict false s
| "finsum" :: s        => addCommPrefix is_comm "finprod"    :: reverseGuessNameDict false s
| "nsmul" :: s         => addCommPrefix is_comm "pow"     :: reverseGuessNameDict false s
--| "nsmul" :: s         => addCommPrefix is_comm "npow"     :: reverseGuessNameDict false s
| "zsmul" :: s         => addCommPrefix is_comm "zpow"     :: reverseGuessNameDict false s
| "add" :: "monoid" :: s      => (addCommPrefix is_comm "monoid")    :: reverseGuessNameDict false s
| "add" :: "submonoid" :: s   => (addCommPrefix is_comm "submonoid") :: reverseGuessNameDict false s
| "add" :: "group" :: s       => (addCommPrefix is_comm "group")     :: reverseGuessNameDict false s
| "add" :: "subgroup" :: s    => (addCommPrefix is_comm "subgroup")  :: reverseGuessNameDict false s
| "add" :: "semigroup" :: s   => (addCommPrefix is_comm "semigroup") :: reverseGuessNameDict false s
| "add" :: "magma" :: s       => (addCommPrefix is_comm "magma")     :: reverseGuessNameDict false s
| "add" :: "haar" :: s        => (addCommPrefix is_comm "haar")      :: reverseGuessNameDict false s
| "add" :: "prehaar" :: s     => (addCommPrefix is_comm "prehaar")   :: reverseGuessNameDict false s
| "add" :: "unit" :: s        => (addCommPrefix is_comm "unit")      :: reverseGuessNameDict false s
| "add" :: "units" :: s       => (addCommPrefix is_comm "units")     :: reverseGuessNameDict false s
| "add" :: s                  => addCommPrefix is_comm "mul"       :: reverseGuessNameDict false s
| "comm" :: s        => reverseGuessNameDict true s
| x :: s             => (addCommPrefix is_comm x :: reverseGuessNameDict false s)
| []                 => bif is_comm then ["comm"] else []

/-- Reverse name autogenerated by `to_additive`. -/
def reverseGuessName : String → String :=
  String.mapTokens ''' $
  fun s => String.intercalate (String.singleton '_') $
  reverseGuessNameDict false (s.splitOn "_")

end ToAdditive

/- Given a theorem name and text from a file  -/
def proofSource (thm : Name) (modulePath : FilePath) : MetaM (Option String) := 
  dbg_trace s!"{thm} : {modulePath}"
  dbg_trace s!"{ToAdditive.guessName thm.toString}"
  dbg_trace s!"{ToAdditive.reverseGuessName thm.toString}"
  
  pure ""

-- awk '/theorem eq_inv_iff_eq_inv/{flag=1;next}/theorem/{flag=0}flag' ./lean_packages/mathlib3port/Mathbin/Algebra/Group/Basic.lean